# 2021-2022 Russia Team Open, High School Programming Contest (VKOSHP XXII)]

- 比赛链接：[link](https://codeforces.com/gym/103483)

- Rank 16, solved 10/12

!!! note "[Problem L. Birthday](https://codeforces.com/gym/103483/problem/L)"

    有 $n$ 张卡片放在桌子上，每张卡片一面写着 $a_i$，另一面写着 $b_i$。每张卡片可以选择任意一面朝上，区间 $[l,r]$ 的权值 $f(l,r)$ 为第 $l\sim r$ 张卡片朝上那面的数值之和，但如果和是 $k$ 的倍数，则权值会被强制置 $0$。

    求 $\sum\limits_{l=1}^{n}{\sum\limits_{r=l}^{n}{f(l,r)}}$，答案对 $10^9+7$ 取模。每个区间权值的计算是独立的，即在统计不同区间时，同一张卡片的状态不必相同。

    $n\leq 5\times 10^5,k\leq 10^9$

如果没有 $k$ 的倍数的限制，显然每张卡片都会选择较大的那面朝上（不妨假设 $a_i\geq b_i$ ）。

现在考虑那些和是 $k$ 的倍数的区间（称为不合法的区间），我们尝试将其中一张卡片翻面，使它不再是 $k$ 的倍数。

秉持着要让区间和最大的目标，我们会选择 $a_i-b_i$ 不是 $k$ 的倍数且最小的那个。

设当前区间 $[L,R]$ 中的“这张”卡片为 $p$，则该区间内的不合法区间 $[l,r](L\leq l\leq p\leq r\leq R)$，都会选择将这张卡翻面，从而变得合法。

而卡片 $p$ 翻面后，区间 $[L,R]$ 被分成了两个小区间，$[L,p-1]$ 和 $[p+1,R]$，递归进去处理即可。

但是，卡片 $p$ 可能并不存在，即所有 $a_i-b_i$ 都是 $k$ 的倍数，此时任何卡片翻面都无法改变区间的合法性（注意这不代表这个区间的所有子区间都是不合法的，例如 $a=[3,1,3],b=[3,1,3]$ ，此时仍然存在合法的区间，例如 $[2,2]$ ，只是子区间 $[1,1],[3,3]$ 不合法的状况无法改变了，需要将它们的权值清零），此时需要统计该区间内的所有不合法区间的权值和，并直接退出。

卡片 $p$ 很好找，用ST表预处理然后区间RMQ查询即可。

下面考虑对于当前区间 $[L,R]$，统计有多少个和为 $k$ 的倍数的子区间 $[l,r]$ 满足 $l\leq p\leq r$。

对序列做前缀和 $psum$（对 $k$ 取余），若 $psum[r]=psum[l-1]$ ，则区间 $[l,r]$ 的和是 $k$ 的倍数。

那么用 `std::map` $cntpsum$ 记录 $[L,R]$ 中每个前缀和出现的次数，子区间 $[l,r]$ 的个数可以这么统计出来：

- 在 $cntpsum$ 中删除 $psum[L\sim p]$
- 枚举 $psum[L-1\sim p]$，累计当前值在 $cntpsum$ 中的出现次数

但是它的操作次数是 $O(p-L)$ 的，若每次 $p=R$，复杂度将退化为区间长度，这无法接受。

那么做后缀和 $ssum$，通过与前缀和统计完全对称的后缀和统计的方法，即可通过 $ssum[p\sim R+1]$ 出现的次数得到子区间的个数。

我们只需要根据左右区间哪个更小，灵活选择用前缀和统计或者后缀和统计，此时的操作次数是 $\min(r-p+1,p-l+1)\leq \frac{R-L+1}{2}$，不会超过区间大小的一半！

类似的，由于我们需要得到当前区间的前后缀和出现次数的`map` $cntpsum/cntssum$，递归到下一层时，根据子区间的大小，它们的`map`会有两种来源（假设 $[L,p-1]$ 更大）：

- 对于 $[L,p-1]$，将$[L,R]$ 的 `map` 中删去 $ssum[p\sim R]$ 和 $psum[p\sim R]$ 
- 对于 $[p+1,R]$，开一个新的 `map`，并将 $ssum[p+1\sim R]$ 和 $psum[p+1\sim R]$ 逐个插入

这样也能保证操作次数不超过区间长度的一半。

复杂度为常数极大的 $O(n\log{n})$ 或者 $O(n\log^2{n})$ ？

反正2000ms的时限几乎是贴着过的（1900+ms），稍微优化了一下跑到了1700ms，还是很慢（队友第二天用另一种方法统计只跑了700ms）。

千万记得关同步，好久没有大数据输入了，5e5的输入`cin` 根本顶不住，读入就T了。

```cpp
#include <bits/stdc++.h>

using namespace std;

const int MOD = 1e9 + 7;
using ll = long long;

struct mint {
    int n;
    mint() : n(0) { ; }
    mint(ll m) {
        if (m < 0 || MOD <= m) {
            m %= MOD;

            if (m < 0)
                m += MOD;
        }

        n = m;
    }
    operator int() {
        return n;
    }
};
bool operator==(mint a, mint b) {
    return a.n == b.n;
}
mint operator+=(mint &a, mint b) {
    a.n += b.n;

    if (a.n >= MOD)
        a.n -= MOD;

    return a;
}
mint operator-=(mint &a, mint b) {
    a.n -= b.n;

    if (a.n < 0)
        a.n += MOD;

    return a;
}
mint operator*=(mint &a, mint b) {
    a.n = ((ll)a.n * b.n) % MOD;
    return a;
}
mint operator+(mint a, mint b) {
    return a += b;
}
mint operator-(mint a, mint b) {
    return a -= b;
}
mint operator*(mint a, mint b) {
    return a *= b;
}
mint operator^(mint a, ll n) {
    if (n == 0)
        return mint(1);

    mint res = (a * a) ^ (n / 2);

    if (n % 2)
        res = res * a;

    return res;
}
ll inv(ll a, ll p) {
    return (a == 1 ? 1 : (1 - p * inv(p % a, a)) / a + p);
}
mint operator/(mint a, mint b) {
    return a * mint(inv(b, MOD));
}
mint operator/=(mint &a, mint b) {
    a = a / b;
    return a;
}

int main() {
    cin.tie(NULL)->sync_with_stdio(false);
    int n, k;
    cin >> n >> k;

    vector<int> a(n + 1), b(n + 1), c(n + 1);

    for (int i = 1, x, y; i <= n; ++i) {
        cin >> x >> y;
        a[i] = max(x, y) - min(x, y);
        b[i] = max(x, y);
        c[i] = (bool)(a[i] % k);
    }

    vector<int> bin(20), lg(n + 1);
    bin[0] = 1;

    for (int i = 1; i < 20; ++i)
        bin[i] = bin[i - 1] * 2;

    for (int i = 2; i <= n; ++i)
        lg[i] = lg[i / 2] + 1;

    auto f = vector(lg[n] + 1, vector(n + 1, 0));

    auto getMin = [&](int x, int y) {
        if (c[x] && c[y])
            return a[x] < a[y] ? x : y;

        return c[x] ? x : y;
    };

    for (int i = 1; i <= n; ++i)
        f[0][i] = i;

    for (int i = 1; i <= lg[n]; ++i) {
        for (int j = 1; j + bin[i] - 1 <= n; ++j) {
            f[i][j] = getMin(f[i - 1][j], f[i - 1][j + bin[i - 1]]);
        }
    }

    auto queryMin = [&](int l, int r) {
        int k = lg[r - l + 1];
        return getMin(f[k][l], f[k][r - bin[k] + 1]);
    };

    unordered_map<int, int> pre, suf;
    vector<int> psum(n + 2), ssum(n + 2);

    for (int i = 1; i <= n; ++i) {
        psum[i] = (psum[i - 1] + b[i]) % k;
        pre[psum[i]]++;
    };

    for (int i = n; i >= 1; --i) {
        ssum[i] = (ssum[i + 1] + b[i]) % k;
        suf[ssum[i]]++;
    }

    auto remove = [&](unordered_map<int, int> &pre, unordered_map<int, int> &suf, int l, int r) {
        for (int i = l; i <= r; ++i) {
            --pre[psum[i]];
            --suf[ssum[i]];
        }
    };

    vector<mint> bsum(n + 1), asum(n + 1);

    for (int i = 1; i <= n; ++i) {
        bsum[i] = bsum[i - 1] + mint(b[i]);
        asum[i] = asum[i - 1] + bsum[i];
    }

    function<mint(int, int, unordered_map<int, int>&, unordered_map<int, int>&)> dfs = [&](int l, int r, unordered_map<int, int> &pre, unordered_map<int, int> &suf) -> mint {
        if (l > r)
            return 0;

        int p = queryMin(l, r);

        if (a[p] % k == 0) {
            unordered_map<int, mint> mp, cnt;

            for (int i = l; i <= r; ++i) {
                mp[psum[i]] += bsum[i];
                cnt[psum[i]] += mint(1);
            }

            mint ans = mp[psum[l - 1]] - cnt[psum[l - 1]] * bsum[l - 1];

            for (int i = l; i <= r; ++i) {
                ans += mp[psum[i]] - cnt[psum[i]] * bsum[i];

                mp[psum[i]] -= bsum[i];
                cnt[psum[i]] -= mint(1);
            }

            return ans;
        }

        int lsz = p - l, rsz = r - p;
        mint cnt = 0, ans = 0, val = a[p];;
        unordered_map<int, int> mpp, mps;

        if (lsz > rsz) {
            remove(pre, suf, p, r);
            ++pre[psum[l - 1]];

            for (int i = p; i <= r; ++i)
                cnt += mint(pre[psum[i]]);

            --pre[psum[l - 1]];
            ans += dfs(l, p - 1, pre, suf);

            for (int i = p + 1; i <= r; ++i)
                mps[ssum[i]]++, mpp[psum[i]]++;

            ans += dfs(p + 1, r, mpp, mps);
        } else {
            remove(pre, suf, l, p);
            ++suf[ssum[r + 1]];

            for (int i = l; i <= p; ++i)
                cnt += suf[ssum[i]];

            --suf[ssum[r + 1]];
            ans += dfs(p + 1, r, pre, suf);

            for (int i = l; i < p; ++i)
                mps[ssum[i]]++, mpp[psum[i]]++;

            ans += dfs(l, p - 1, mpp, mps);
        }

        return ans + cnt * val;
    };

    mint ans = 0, sum = asum[n];

    for (int i = 1; i <= n; ++i) {
        ans += sum - mint(n - i + 1) * bsum[i - 1];
        sum -= bsum[i];
    }

    cout << ans - dfs(1, n, pre, suf) << endl;
    return 0;
}
```

