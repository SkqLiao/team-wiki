# XXII Open Cup, Grand Prix of Korea

- 比赛链接：[link](https://codeforces.com/gym/103371)

- Rank 135, solved 3/13

惨遭滑铁卢。

!!!note "[C.Equivalent Pipelines](https://codeforces.com/gym/103371/problem/C)"

    给定$D$棵有$n$个点的树，两棵树是相似的当且仅当每个点对$(i,j)$，$i,j$路径上边权最小值都相等。问和每棵树相似的编号最小的树是哪棵（包括自己）。

    $n\cdot D\leq 5\times 10^5,1\leq w_i\leq 10^9$

首先我们需要知道如何判断两颗树是不是相似。

边权最小值相当，那就是从大到小加边，当前权值的边会连通两个或多个点集。两棵树相似当且仅当每次加入某个权值的边时，新联通的点对都相同。换句话说，我们需要快速判断连通的点集是否相同，显然我们需要哈希。而且这个哈希方式需要满足，每个连通块的权值不会受到加入某相同权值边的顺序的影响。

vp的时候我胡的哈希方式是：加入权值$w$的边将若干个点集连通，新的权值就是这些点集的权值和乘上$w$，而哈希值是所有新形成的连通块的权值乘积。

赛后看别人的写法，发现只要定义为新连通的点集权值乘积之和再乘边权即可，这样只需要按顺序加边$(u,v)$，每次并查集查一下根，$sum+=f[x]\cdot f[y]\cdot w,f[y]+=x$就是对的了，甚至可以只返回最后的结果，不需要比对中间结果。

但是事实上vp的时候没过，甚至双哈希也没过，赛后看别人代码才知道每个点的初始权值不能为$i$这样很容易发生冲突，一般的做法是随机一个比较大的初始权值。

另外其实元素权值比较大可以使用一个大素数模数，比如$1e17+7$这种。

复杂度$O(nD\log n)$

!!!note "[G.Lamb's Respite](https://codeforces.com/gym/103371/problem/G)"

    千珏将会受到$n$次操作$a_i$，每次血量会$+=a_i$，血到0或以下就寄了。千珏放大的时候可以锁血，假如血上限是$H$，那么放大期间如果血量小于等于$\lceil \frac H {10} \rceil$，它就会一直是$\lceil \frac H {10} \rceil$（包括）。

    现在有$Q$个操作：

    - 假如千珏血上限是$x$，问在$[l,r]$放大最终的血量（或0表示死了）
    - 修改$a_i$为$x$，修改会继承。

显然我们可以把整个拆成三段操作。

考虑什么时候最容易寄，显然是最小子段和的时候。假如最小子段和是$[l,r]$，意味着这期间都会是扣血，而且这之前如果没死一定是满血，这之后如果没死血量一定不会更低。

对于最后的血量计算，只需要求出最小后缀和的位置可以简单得到，因为最小后缀和实际上是最后一个可能顶到血上限的位置。

于是我们线段树维护区间最小子段和以及最小后缀（这个最小子段和也顺便维护了），还有区间和即可。

复杂度$O(n\log n)$