# 2022 Shanghai Collegiate Programming Contest

- 比赛链接：[link](https://codeforces.com/gym/103931)

- Rank 69, solved 6/14

状态很差，一堆题能开但是没开出来。

!!!note "[L. Last Warning of the Competition Finance Officer](https://codeforces.com/gym/103931/problem/L)"

    给定一个字符串$s$和$n$个匹配串$t_i$，匹配串有权值$w_i$，定义一个串的价值为，选择串中任意不相交子串的价值乘积之和，同时要求子串是匹配串之一，空串的价值为1。求$s$的每个前缀的价值，对998244353取模。
    
    $n,|s|,\sum |t_i|\leq 2\times10^5$

我们设$f_i$表示前缀$i$的答案，那么有一个显然的转移：

$$
f_i=\sum f_jw_k
$$

其中$[j+1,i]$是第$k$个匹配串。

这样显然是$n^2$的，但是一个很经典的trick是匹配串至多只有$\log$种不同的长度。于是我们可以枚举长度，用哈希判断结尾。复杂度是$O(n\sqrt n\cdot \log n)$的，有个哈希的$\log$，而且常数很大，并不能通过。

考虑这个匹配的过程，实际上我们可以建立AC自动机，$s$在自动机上匹配的时候，我们只要从当前点一直跳fail就能获得所有的匹配情况。但是暴力跳是不行的，我们需要预处理出每个点往上跳能跳到的最近的匹配串的位置是哪。这样我们利用这个信息跳就是$O(n\sqrt n)$的了。

```cpp
#include<bits/stdc++.h>
#define rep(i,a,b) for(int i=(a),i##ss=(b);i<=i##ss;i++)
#define dwn(i,a,b) for(int i=(a),i##ss=(b);i>=i##ss;i--)
#define rng(i,a,b) for(int i=(a);i<(b);i++)
#define deb(x) cerr<<(#x)<<":"<<(x)<<'\n'
#define pb push_back
#define mkp make_pair
#define fi first
#define se second
#define int long long
#define hvie '\n'
#define read yh
using namespace std;
typedef pair<int,int> pii;
typedef long long ll;
typedef unsigned long long ull;
typedef double db;

int yh(){
	int ret=0;bool f=0;char c=getchar();
	while(!isdigit(c)){if(c==EOF)return -1;if(c=='-')f=1;c=getchar();}
	while(isdigit(c))ret=(ret<<3)+(ret<<1)+(c^48),c=getchar();
	return f?-ret:ret;
}
const int N=4e5+10,M=27,mod=998244353;

struct ACM{
	int cnt=1;
	int ch[N][M],val[N],fail[N],len[N],preed[N];
	void insert(char *s,int v){
		int m=strlen(s+1),now=0;
		for(int i=1;i<=m;++i){
			int c=s[i]-'a';
			if(!ch[now][c]) ch[now][c]=++cnt;
			len[ch[now][c]]=len[now]+1;
			now=ch[now][c];
		}
		val[now]=v;
	}
	void build(){
		queue<int>q;
		for(int i=0;i<26;++i){
			if(ch[0][i]) q.push(ch[0][i]),fail[ch[0][i]]=0;
		}
		fail[1]=0;
		while(!q.empty()){
			int u=q.front();q.pop();
			for(int i=0;i<26;++i){
				if(ch[u][i]) fail[ch[u][i]]=ch[fail[u]][i],q.push(ch[u][i]);
				else ch[u][i]=ch[fail[u]][i];
			}
			if(val[fail[u]]) preed[u]=fail[u];
			else preed[u]=preed[fail[u]]; 
		}
	}
}T;

int n,val[N],f[N];
char s[N],t[N];

signed main(){
	scanf("%s",s+1);scanf("%lld",&n);
	for(int i=1;i<=n;++i){
		scanf("%s",t+1);scanf("%lld",&val[i]);
		T.insert(t,val[i]);
	}
	T.build();
	//puts("!!");
	n=strlen(s+1);f[0]=1;
	for(int i=1,now=0;i<=n;++i){
		f[i]=f[i-1];
		now=T.ch[now][s[i]-'a'];
		for(int j=now;j;j=T.preed[j]){
			f[i]+=T.val[j]*f[i-T.len[j]];
			f[i]%=mod;
		}
		
	}
	for(int i=1;i<=n;++i) printf("%lld ",f[i]);
	return 0;
}
```
