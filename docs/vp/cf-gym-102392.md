# 2019-2020 ICPC Southeastern European Regional Programming Contest (SEERC 2019)

- 比赛链接：[link](https://codeforces.com/gym/102392)

- Rank 22, solved 8/11

感觉并不是很难，不过还是有妙妙题的。

### A. Max or Min

假如我们要让所有数变为$k$，首先需要存在$k$这个数，接着不难发现一定可以构造出一种方案。然后可以发现，我们其实只关心一个数和$k$的大小关系，不妨令$a[i]<k$变为-1，$a[i]>k$变为1，$a[i]=k$变为0，对于一个全1或者全-1段，需要操作的次数就是长度次。对于一个1和-1交错的长度为$L$的段，需要先把其中少的一半变为最小/大才能操作，即(0,1,-1,1,-1,1)\rightarrow (0,1,1,1,1,1)\rightarrow (0,0,0,0,0,0)$。于是额外操作$\frac \lfloor {L} 2 \rfloor$次。那么总的贡献就是$cnt_{-1}+cnt_{1}+\sum_L \frac \lfloor {L} 2 \rfloor$。

用线段树维护这个变化的过程即可，复杂度$O(n\log n)$。

### B. Level Up


### C. Find the Array

这个题很好玩啊，首先不难发现我们可以二分得到一个极值的位置（尽管不知道它是多少），于是最多$8+1$次可以得到位置和值，我们需要考虑如何通过这个极值获取所有信息。次数很少，肯定考虑$O(\log )$相关的做法，倍增和二分都是不行的，因为在过程中，除了极值外数带来的信息，由于相对位置不知道，我们并不能确定哪些有用。

再读一下题，发现这个题又要求位置，又要求值，那么要么值能够通过关于位置的询问得出，要么位置能够通过关于值的询问得出。这里要$O(\log )$，而且给出的回答是一堆值，那么我们只能关于位置做文章。一个经典的想法是分治——我们可以通过二进制分组把除极值$pos$外所有下标分组。假设有集合$p_j$，分别询问$p_j\cup pos$和$p_j$，做差后我们可以得到所有$p_j$下标中关于极值的差的绝对值，这个值是唯一的。接下来只需要枚举这个差值，我们可以知道差值在哪些组中出现过，也就知道对应的下标是多少了。最后再随便询问一个其他的值可以知道这是最小值还是最大值，根据差值就可以算出来原序列了。

次数是$8+1+1+8+8=26$次的。

### D. Cycle String?

分类讨论：

- 只有一种字母显然No
- 有三种以上的字母是Yes
- 有两种字母，特判$n<=2$的情况，然后如果其中一种出现不足3个为No，否则Yes

具体构造，只需要类似放$n$个$a$，一个$b$，剩下的排序放即可。

### E. Life Transfer


### F. Game on a Tree

显然是个无向图博弈，即一个点和它子树中所有点连双向边形成的图。
判断是否有完美匹配，设$f[i]$表示子树中最少有多少个点没有匹配到即可。

### G. Projection


### H. Tree Permutations


### I. Absolute Game


### J. Graph and Cycles


### K. Stranded Robot
